[{"id":0,"href":"/awesome-open-source-guides/guides/","title":"Guides","parent":"The Awesome Open Source Guides","content":"","description":""},{"id":1,"href":"/awesome-open-source-guides/guides/home-assistant/adding-devices/","title":"Adding your first Device to Home Assistant","parent":"Home Assistant","content":"For the purpose of this tutorial we are using the following setup:\nA Linux based installation of Home Assistant either using a container or the Home Assistant Operating System A ZigBee connector compatible with the ZigBee Home Automation Integration, e.g. the Nortek GoControl USB Zigbee/Zwave or the Sonoff Zigbee 3.0 USB Dongle plus Aqara Motion Sensor or Aqara Motion Sensor P1 (both use Zigbee) At this point you should have the ZigBee Home Automation set up and ready to talk to the Zigbee network. It should look something like this under \u0026lsquo;Settings\u0026rsquo; → \u0026lsquo;Devices\u0026rsquo; (it might have no devices if you have not added any):\nThe Zigbee Home Automation card in the Settings of Home Assistant Adding a ZigBee device is very similar to pairing a Bluetooth device on your phone. The device needs to be set into \u0026ldquo;pairing\u0026rdquo; mode and then the server (in this case Home Assistant) needs to search for it.\nFirst, you need to set the device into pairing mode. For the Aqara Motion sensor, press the small, indented button for five seconds.\nOnce it\u0026rsquo;s in pairing mode, start the device search in Home Assistant. The device search can be found under Settings → Devices and Services → Zigbee (click on the devices link) → Add device.\nThe Zigbee Home Automation is looking for Zigbee devices in proximity in pairing mode. It might take anywhere from 10-30 seconds for the device to show up. Sometimes it is necessary to \u0026ldquo;wake\u0026rdquo; the device. Just press the indented button which should make the blue LED flash.\nOnce the device has been found Home Assistant will display the following:\nThe Aqara Motion Sensor will show up as a card outlined in green once it has been discovered and added to Home Assistant. The icons show that it found a battery, temperature, motion and illumination sensors on the device.\nAfter picking an \u0026lsquo;area\u0026rsquo; the device is ready to be used (it might take another 30-60 seconds for the search to finish even after it has found the device, but you can close this page beforehand). For the purpose of this guide, the motion sensor has been assigned to the \u0026lsquo;Library\u0026rsquo; area:\nProperties of the Aqara Motion Sensor in the ZigBee Home Automation. The battery isn\u0026rsquo;t always correct for some reason. But the temperature, illuminance and all other sensors should work correctly.\nThe last step is choosing what to automate. On the sensor screen, click on the \u0026lsquo;+\u0026rsquo; next to automations. The following options will show up\nTemplate automations available for motion sensors. A simple choice is to click on \u0026lsquo;started detecting motion\u0026rsquo;. This will take you to the \u0026lsquo;New Automation\u0026rsquo; section.\n","description":"For the purpose of this tutorial we are using the following setup:\nA Linux based installation of Home Assistant either using a container or the Home Assistant Operating System A ZigBee connector compatible with the ZigBee Home Automation Integration, e.g. the Nortek GoControl USB Zigbee/Zwave or the Sonoff Zigbee 3.0 USB Dongle plus Aqara Motion Sensor or Aqara Motion Sensor P1 (both use Zigbee) At this point you should have the ZigBee Home Automation set up and ready to talk to the Zigbee network."},{"id":2,"href":"/awesome-open-source-guides/categories/","title":"Categories","parent":"The Awesome Open Source Guides","content":"","description":""},{"id":3,"href":"/awesome-open-source-guides/guides/home-assistant/configure-wireguard/","title":"Configure Wireguard VPN for Remote Access","parent":"Home Assistant","content":"Wireguard is a simple, yet powerful VPN solution that is both fast and very easy to setup in contrast to e.g. openVPN. It can be utilized to access your Home Assistant instance securely from anywhere in the world.\nPrerequisites Home Assistant running on a Linux machine a machine with a static hostname/IP, e.g. a VPS in a public cloud Configuring the Server Your server needs to run at least Kernel 5.6 to support Wireguard and you have to install the wireguard userspace tools in addition to that. Find the installation instructions for your operating system on the Wireguard home page.\nWireguard can be installed and configured on the system directly as follows.\nCreate the wireguard keys: ❯ cd /etc/wireguard ❯ umask 077 ❯ wg genkey | tee privatekey | wg pubkey \u0026gt; publickey The public key can then be found in the file /etc/wireguard/publickey while the private key has been written to /etc/wireguard/privatekey.\nKeep the private key secure! Anyone with access to it can impersonate your machine and gain access to your network. Create the configuration file /etc/wireguard/wg0.conf: [Interface] Address = 10.200.200.1/24 ListenPort = 51820 PrivateKey = # insert /etc/wireguard/privatekey here # optional PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE Start the wireguard tunnel via systemctl enable --now wg-quick@wg0 and allow wireguard to be accessed through the firewall. For firewalld execute: firewall-cmd --add-service=wireguard --permanent. Configuring your Home Assistant Machine We have to repeat the first step of the server setup of Wireguard on the machine which is running Home Assistant as well, however our configuration file /etc/wireguard/wg0.conf will be different:\n[Interface] PrivateKey = # insert /etc/wireguard/privatekey here Address = 10.200.200.2/24 PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o wlp59s0 -j MASQUERADE PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o wlp59s0 -j MASQUERADE ListenPort = 51820 [Peer] PublicKey = # /etc/wireguard/publibkey from the server Endpoint = # IP of the server AllowedIPs = 10.200.200.0/24 PersistentKeepalive = 25 # optional, but recommended for reliable reconnects You now have to register this peer on the server as well. Append the following entry to /etc/wireguard/wg0.conf on the server:\n[Peer] PublicKey = # insert /etc/wireguard/publickey of Home Assistant AllowedIPs = 10.200.200.2/32 PersistentKeepalive = 25 # optional, but recommended for reliable reconnects After restarting wireguard on the server via systemctl restart wg-quick@wg0, you can enable wireguard on this machine as well: systemctl enable --now wg-quick@wg0.\nYour Home Assistant machine and the server should now be able to reach each other. You can verify this by e.g. pinging the server from Home Assistant via: ping 10.200.200.1 or by executing wg show wg0 on either of the machines which look roughly like the following:\n# wg show wg0 interface: wg0 public key: VM9jO8G6pH43KIobViKFB9gk3Z9WK65oONLIAa8lEC8= private key: (hidden) listening port: 51820 peer: sA1VKDhTDYDsaEvDHGXhHJMd/nT9NTgD5ICO/DT6V2w= endpoint: # ENDPOINT IP will appear here allowed ips: 10.200.201.0/24 latest handshake: 51 seconds ago transfer: 23.26 MiB received, 15.24 MiB sent persistent keepalive: every 25 seconds Adding peers to your Wireguard VPN Adding a new peer to your VPN is the same process on the server irrespective of the client OS. You have to append a new [Peer] entry to /etc/wireguard/wg0.conf on the server:\n[Peer] PublicKey = # insert /etc/wireguard/publickey or the public key from the new peer AllowedIPs = 10.200.200.N/32 # increment N from your last peer PersistentKeepalive = 25 # optional, but recommended for roaming peers and restart wireguard on the server.\nLinux Adding Linux hosts is completely analogous to configuring the Home Assistant machine. Follow the above guide, but change the Address value in /etc/wireguard/wg0.conf to the same address that you added to the server\u0026rsquo;s /etc/wireguard/wg0.conf.\nWindows Android Connecting your Android phone to the Wireguard network is very simple, especially if you have access to a Linux machine. Then you can generate the configuration for wireguard on the Linux machine and transfer it as a QR code to your phone.\nInstall the Wireguard App from either the Google Play Store or FDroid.\nGenerate a new configuration file as you would for a Linux host and save it somewhere on your file system, e.g. /tmp/wg0.conf.\nConvert the configuration file into a qrcode using qrencode:\nqrencode -t ansiutf8 \u0026lt; \u0026#34;/tmp/wg0.conf\u0026#34; Open the Wireguard App on your phone, click the plus sign in the bottom right corner, select \u0026ldquo;scan from QR code\u0026rdquo; and scan the QR code that appeared in your terminal.\nActivate the connection in the Wireguard App using the toggle next to the tunnel name.\nAlternatives If you do not own a VPS and do not want to run one as your wireguard server, you can use tailscale to setup a wireguard network without a central instance.\nYou can also run wireguard itself from within a container, if you do not want to run it on your host system. This allows you to only allow certain containers to have access to the wireguard network and can be used for a more declarative system configuration. A good wireguard container is Thorsten Kukuk\u0026rsquo;s Wireguard container based on openSUSE or the linuxserver/wireguard image (this one does not function on non-Ubuntu/Debian systems!).\n","description":"Wireguard is a simple, yet powerful VPN solution that is both fast and very easy to setup in contrast to e.g. openVPN. It can be utilized to access your Home Assistant instance securely from anywhere in the world.\nPrerequisites Home Assistant running on a Linux machine a machine with a static hostname/IP, e.g. a VPS in a public cloud Configuring the Server Your server needs to run at least Kernel 5."},{"id":4,"href":"/awesome-open-source-guides/guides/home-assistant/","title":"Home Assistant","parent":"Guides","content":" What is Home Assistant? Home Assistant is an Open Source Home Automation software that integrates with a plethora of existing smart home frameworks and integrates these all together. In contrast to proprietary frameworks, Home Assistant integrates with many other existing ecosystems (e.g. Amazon Alexa or Apple Homekit) and focuses on local control and privacy.\nDepending on the type of your smart home device, Home Assistant can be run on your local network and without internet access.\nWhat can Home Assistant do for you? Home Assistant allows you to regain control over your smart home devices without relying on external cloud providers or any internet connection at all (this is only possible if your smart home devices actually support running without a cloud).\nAdditionally, Home Assistant features a very intuitive UI including companion apps for IOS and Android, complex automations, support for energy tracking, a scene system and much, much more.\nIrrespective whether you just like to turn that one light on or off from your phone or you\u0026rsquo;d like to go down the automation rabbit hole completely, Home Assistant has you covered.\nExample Home Assistant Dashboard showing different cards for controlling your smart home ","description":"What is Home Assistant? Home Assistant is an Open Source Home Automation software that integrates with a plethora of existing smart home frameworks and integrates these all together. In contrast to proprietary frameworks, Home Assistant integrates with many other existing ecosystems (e.g. Amazon Alexa or Apple Homekit) and focuses on local control and privacy.\nDepending on the type of your smart home device, Home Assistant can be run on your local network and without internet access."},{"id":5,"href":"/awesome-open-source-guides/guides/home-assistant/home-assistant-microos-rpi/","title":"Setting up Home Assistant with openSUSE MicroOS on a Raspberry Pi","parent":"Home Assistant","content":"openSUSE MicroOS is a small operating system designed to run container workloads. It features a read only root partition, transactional updates which allow for easy rollbacks thereby making it highly resilient and perfect for running small IoT devices.\nHome Assistant can be run very easily from within a container preferably on a system requiring as little maintenance as possible. This makes MicroOS the perfect operating system for deploying Home Assistant.\nIn this guide, we will show how to install MicroOS on your Raspberry Pi, configure it with ignition and deploy Home Assistant using podman and systemd.\nPrerequisites You will need the following hardware:\nRaspberry Pi 4 + Power Supply Micro SD-Card USB drive PC with a SD-Card reader and a Micro SD Adapter Ethernet cable This guide will assume that your PC is running Linux. You can perform most of these steps on Windows or MacOS, but some of the commands will require adjustment.\nInstall MicroOS Download the latest MicroOS image (aarch64 variant, Base System + Container Runtime Environment) from download.opensuse.org\nInsert the SD Card into your PC and find out which device name corresponds to it, e.g. via udiskctl status or lsblk:\n❯ udisksctl status MODEL REVISION SERIAL DEVICE -------------------------------------------------------------------------- ADATA SX8200PNP 42G1TBKA 2L08294NSJU9 nvme0n1 ST2000LM007-1R8174 SDM2 WDZG289H sda SE32G 0x0f6986e5 mmcblk0 ❯ # The micro SD Card would be mmcblk0 Flash the downloaded image to the correct device. Double check the correct path or you might accidentally overwrite important data! ❯ xzcat /path/to/download/folder/openSUSE-MicroOS.aarch64-ContainerHost-RaspberryPi.raw.xz | \\ dd bs=4M of=/dev/mmcblk0 iflag=fullblock oflag=direct status=progress # wait a bit ❯ sync Grab the spare USB drive and either create a new partition on it with the label ignition or relabel the existing partition as ignition (e.g. via gparted). Create a directory called ignition in the root directory of the USB drive and put the file config.ign with the following contents into it: { \u0026#34;ignition\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;3.0.0\u0026#34; }, \u0026#34;passwd\u0026#34;: { \u0026#34;users\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;sshAuthorizedKeys\u0026#34;: [ \u0026#34;ssh-rsa insertYourPublicKeyHere\u0026#34; ] } ] } } Replace the line ssh-rsa insertYourPublicKeyHere with your preferred ssh public key that you can find in ~/.ssh/id_*.pub.\nUnmount the SD-Card and the USB drive, insert both into your Raspberry Pi, connect it to your local network using an Ethernet cable and power it on.\nGet the IP address of your Raspberry Pi. You can use your router\u0026rsquo;s web interface for this (if you have access to it). Alternatively, you can scan all PCs in your local network using nmap:\n❯ nmap -p22 -v 192.168.1.* # adjust to your IP range # lots of output... Nmap scan report for 192.168.1.107 Host is up (0.00018s latency). PORT STATE SERVICE 22/tcp open ssh MAC Address: B8:27:EB:64:2C:20 (Raspberry Pi Trading) Or use any other port scanner, e.g. PortAuthority for Android:\nPort authority scan revealing the Raspberry Pi Log in to your Pi and update all packages: ❯ ssh root@$RPI_IP_HERE localhost:~ # transactional-update Checking for newer version. transactional-update 4.0.0~rc4 started Options: Separate /var detected. 2022-08-18 13:35:48 tukit 4.0.0~rc4 started 2022-08-18 13:35:48 Options: -c1 open 2022-08-18 13:35:48 Using snapshot 1 as base for new snapshot 2. 2022-08-18 13:35:48 No previous snapshot to sync with - skipping ID: 2 2022-08-18 13:35:49 Transaction completed. Calling zypper up zypper: nothing to update Removing snapshot #2... 2022-08-18 13:35:52 tukit 4.0.0~rc4 started 2022-08-18 13:35:52 Options: abort 2 2022-08-18 13:35:52 Discarding snapshot 2. 2022-08-18 13:35:52 Transaction completed. transactional-update finished localhost:~ # reboot # only if packages were actually updated Setup Home Assistant We will now setup Home Assistant to be run via podman in a systemd unit and optionally enable automatic updates of the container image.\nLog in to the Raspberry Pi and proceed as follows:\nCreate a directory for Home Assistant\u0026rsquo;s configuration files and database and switch to it: ❯ ssh root@$RPI_IP_HERE localhost:~ # mkdir -p /path/to/conf/dir localhost:~ # podman run -d -v /path/to/conf/dir:/config:Z \\ -v /etc/localtime:/etc/localtime:ro \\ --privileged --network=host \\ --name=homeassistant \\ --label \u0026#34;io.containers.autoupdate=registry\u0026#34; \\ ghcr.io/home-assistant/home-assistant:stable Create a systemd unit using podman and enable it at startup. Now Home Assistant will be automatically started whenever the Raspberry Pi is rebooted. localhost:~ # podman generate systemd --new homeassistant \u0026gt; \\ /etc/systemd/system/homeassistant.service localhost:~ # podman stop homeassistant homeassistant localhost:~ # systemctl daemon-reload localhost:~ # systemctl enable --now homeassistant Created symlink /etc/systemd/system/default.target.wants/homeassistant.service → /etc/systemd/system/homeassistant.service. Depending on your preferences, you can enable automatic updates of the Home Assistant container image using podman\u0026rsquo;s auto-update command. podman will pull a new version of all images with the label io.containers.autoupdate set to registry every time podman auto-update is run. You can either run podman auto-update yourself whenever you consider safe to do or let systemd perform the update periodically by enabling the podman-auto-update.timer: localhost:~ # systemctl enable --now podman-auto-update.timer Created symlink /etc/systemd/system/timers.target.wants/podman-auto-update.timer → /usr/lib/systemd/system/podman-auto-update.timer. Home Assistant is now running on your Raspberry Pi and you can go through the onboarding process.\nGoing forward We have only scratched the surface of what can be achieved with MicroOS as a host operating system. There are multiple areas where this setup can be improved further:\nLeverage (health-checker)[https://github.com/openSUSE/health-checker] to verify whether Home Assistant is able to launch with a new snapshot. Use ignition to its full potential and setup Home Assistant completely automated via ignition. Setup proper monitoring There is a lot to tinker with, so go and check out the MicroOS Portal in the openSUSE Wiki to find out more.\n","description":"openSUSE MicroOS is a small operating system designed to run container workloads. It features a read only root partition, transactional updates which allow for easy rollbacks thereby making it highly resilient and perfect for running small IoT devices.\nHome Assistant can be run very easily from within a container preferably on a system requiring as little maintenance as possible. This makes MicroOS the perfect operating system for deploying Home Assistant."},{"id":6,"href":"/awesome-open-source-guides/tags/","title":"Tags","parent":"The Awesome Open Source Guides","content":"","description":""},{"id":7,"href":"/awesome-open-source-guides/guides/home-assistant/telegram-notifications/","title":"Telegram Notifications from Home Assistant","parent":"Home Assistant","content":" Home Assistant can communicate with you and others using the Telegram messenger. You can use Telegram to receive alerts and control your smart home from anywhere in the world with an internet connection. Home Assistant can send notifications via a plethora of messaging services including the popular messenger Telegram, allowing you to receive real time notifications without having direct access to your Home Assistant instance. Additionally, you can also configure the telegram integration to respond to your commands, for example to disarm your alarm or to water your plants while you\u0026rsquo;re on vacation.\nCreating a Telegram Bot Account You have to create a Telegram bot account to be able to send and receive messages from Home Assistant. A bot account can be created with a few simple steps by messaging the BotFather Bot:\nProcess of creating a bot via the BotFather bot. The BotFather will send you a token (hidden under the red rectangle) when the bot has been successfully created. Start by entering the command /newbot. Then you will be prompted for the name of the bot, where you can pick anything that you want. After that, you have to pick a unique username of this bot. The only limitation is that it must end with bot and no bot account with this name must exist. In case your desired username is already taken, try a new one (you do not have to restart the whole process).\nOnce your bot has been successfully created, you will get a message from the BotFather with a token (it would appear in place of the red rectangle in the above image). Save this token and keep it secure as it can be used to impersonate your bot!\nYou can now customize your bot further if you like to, e.g. set its description via /setdescription or change the bot\u0026rsquo;s profile picture via /setuserpic as shown in the image below: You can set the Bot\u0026#39;s profile picture using the /setuserpic command via the BotFather and uploading a new profile image. Obtaining the Chat IDs Home Assistant will only communicate with the users or groups that you allow it to and will ignore everyone else. This ensures that only users that you specify can receive alerts or issue commands via the bot. Users and groups are identified via a Chat ID, which can be obtained as follows.\nIf you want the bot to only communicate with your account, then you can use the GetIDs Bot for that. Message the GetIDs Bot, type /start and grab the Chat ID from its reply:\nObtain your user\u0026#39;s Chat ID by messaging the GetIDs bot. The Chat ID is in the bot\u0026#39;s reply in the line id, hidden under the red rectangle. Obtaining the Chat IDs of additional users can also be performed via the GetIDs bot. Ask the user to message the GetIDs Bot bot and send you the Chat ID.\nYou can also use the Telegram API itself to retrieve the Chat IDs. Going via the API is necessary when adding your bot to groups and it allows you to obtain the Chat IDs of all recent conversations. To obtain a group\u0026rsquo;s or a user\u0026rsquo;s Chat ID, add your bot to the respective group or ask the user to chat with the bot account. In both cases, you must activate the bot in each conversation (i.e. every user and every group have to perform this action) by sending it a /start message in the chat. Once this has happened, send a GET request to https://api.telegram.org/bot\u0026lt;YOUR_API_TOKEN\u0026gt;/getUpdates, e.g. via curl and jq:\n❯ curl -X GET https://api.telegram.org/bot$API_TOKEN/getUpdates|jq % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 2088 100 2088 0 0 14887 0 --:--:-- --:--:-- --:--:-- 14914 { \u0026#34;ok\u0026#34;: true, \u0026#34;result\u0026#34;: [ { \u0026#34;update_id\u0026#34;: 121143347, \u0026#34;message\u0026#34;: { \u0026#34;message_id\u0026#34;: 3, \u0026#34;from\u0026#34;: { \u0026#34;id\u0026#34;: USER_CHAT_ID, \u0026#34;is_bot\u0026#34;: false, \u0026#34;first_name\u0026#34;: \u0026#34;USER_FIRST_NAME\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;USERNAME\u0026#34;, \u0026#34;language_code\u0026#34;: \u0026#34;en\u0026#34; }, \u0026#34;chat\u0026#34;: { \u0026#34;id\u0026#34;: USER_CHAT_ID, \u0026#34;first_name\u0026#34;: \u0026#34;USER_FIRST_NAME\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;USERNAME\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;private\u0026#34; }, \u0026#34;date\u0026#34;: 1661350108, \u0026#34;text\u0026#34;: \u0026#34;test\u0026#34; } }, { \u0026#34;update_id\u0026#34;: 121143348, \u0026#34;message\u0026#34;: { \u0026#34;message_id\u0026#34;: 4, \u0026#34;from\u0026#34;: { \u0026#34;id\u0026#34;: SOME_USER_CHAT_ID, \u0026#34;is_bot\u0026#34;: false, \u0026#34;first_name\u0026#34;: \u0026#34;SOME_USER_FIRST_NAME\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;SOME_USER_NAME\u0026#34;, \u0026#34;language_code\u0026#34;: \u0026#34;en\u0026#34; }, \u0026#34;chat\u0026#34;: { \u0026#34;id\u0026#34;: GROUP_CHAT_ID, \u0026#34;title\u0026#34;: \u0026#34;GROUP_TITLE\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;group\u0026#34;, \u0026#34;all_members_are_administrators\u0026#34;: true }, \u0026#34;date\u0026#34;: 1661350208, \u0026#34;text\u0026#34;: \u0026#34;/start\u0026#34;, \u0026#34;entities\u0026#34;: [ { \u0026#34;offset\u0026#34;: 0, \u0026#34;length\u0026#34;: 6, \u0026#34;type\u0026#34;: \u0026#34;bot_command\u0026#34; } ] } }, ] } The Chat ID are in the message.chat.id field of the result array. You can obtain the Chat IDs only with a jq filter:\n❯ curl -X GET https://api.telegram.org/bot$API_TOKEN/getUpdates | \\ jq \u0026#39;.[\u0026#34;result\u0026#34;] | .[].message.chat.id\u0026#39;|sort|uniq % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed 100 2088 100 2088 0 0 13210 0 --:--:-- --:--:-- --:--:-- 13215 CHAT_ID_1 CHAT_ID_2 CHAT_ID_3 GROUP_ID_1 null Note that Chat IDs with users are always positive and Group IDs are always negative. There is no need to worry in case the above command lists a null entry, this just means that there was an event not belonging to a specific chat (e.g. when the bot is removed from a conversation).\nAdding the bot to Home Assistant The telegram integration cannot be added by the web interface, you have to add the following snippet into configuration.yaml in Home Assistant\u0026rsquo;s configuration directory:\ntelegram_bot: - platform: polling api_key: $BOT_TOKEN allowed_chat_ids: - $CHAT_ID1 - $CHAT_ID2 Replace $BOT_TOKEN with the token that you got from the BotFather and insert the Chat IDs of all chats that the bot shall communicate with.\nUsing the bot to send messages Sending alerts or simple messages can be achieved using the telegram notification platform or by using the telegram_bot.send_message service. The advantage of the notification platform is that you can define chats and give them a name for easier usage in automations.\nTo setup the telegram notification platform, add the following lines to configuration.yaml:\nnotify: - platform: telegram name: telegram_direct_message_to_user_1 chat_id: $CHAT_ID_1 - platform: telegram name: telegram_direct_message_to_user_2 chat_id: $CHAT_ID_2 You can then use the notification service directly as an action in an automation. When creating automations via the web interface, scroll down to the \u0026ldquo;Actions\u0026rdquo; part, select Call Service as the Action type and enter the name from configuration.yaml into the Service field:\nSend a telegram message using the telegram notification platform as part of an automation. Select \u0026#34;Call Service\u0026#34; as the \u0026#34;Action type\u0026#34; (outlined in green) and pick the name of the notification that you defined in configuration.yaml as the \u0026#34;Service\u0026#34; (outlined in blue). Or when creating an automation via YAML, use the following snippet to send a notification as an action:\nservice: notify.telegram_direct_message_to_user_1 data: message: Telegram message body title: Telegram message title The other option is to use the telegram_bot.send_message service directly. It allows you to further customize the message that is sent in contrast to the notification platform. On the other hand, you have to specify the chat id for every service call (unless you are sending a message to the first specified chat id from your configuration.yaml).\nTo use the telegram_bot.send_message action in an automation that has been created via the web interface, select Call Service as the Action type and enter telegram_bot.send_message into the Service field as shown in the image below. Customize the message to your desire and optionally specify the Chat ID to which the message will be delivered.\nSend a messages using the telegram send_message service as an action in an automation. Select \u0026#34;Call Service\u0026#34; as the \u0026#34;Action type\u0026#34; (outlined in green) and pick telegram_bot.send_message as the \u0026#34;Service\u0026#34; (outlined in blue). Or when adding an action in yaml add the following snippet into automations.yaml:\nservice: telegram_bot.send_message data: title: \u0026#34;Optional message title\u0026#34; message: \u0026#34;Telegram message body\u0026#34; Further reading Documentation of the telegram_bot integration including examples.\nExample how to create an interactive automation: https://siytek.com/home-assistant-telegram-bot/#Create-text-automation-example\n","description":"Home Assistant can communicate with you and others using the Telegram messenger. You can use Telegram to receive alerts and control your smart home from anywhere in the world with an internet connection. Home Assistant can send notifications via a plethora of messaging services including the popular messenger Telegram, allowing you to receive real time notifications without having direct access to your Home Assistant instance. Additionally, you can also configure the telegram integration to respond to your commands, for example to disarm your alarm or to water your plants while you\u0026rsquo;re on vacation."},{"id":8,"href":"/awesome-open-source-guides/","title":"The Awesome Open Source Guides","parent":"","content":"Welcome to the Awesome Open Source Guides, a collection of Guides, Tutorials and Links about using and running Open Source.\nScope This project is focused on the usage of open source and less on running open source projects or maintaining a community. There are other great collections, guides or books about those topics, including but not limited to Cornelius Schumacher\u0026rsquo;s awesome-open-source or Daniel Stenberg\u0026rsquo;s Uncurled.\nContributing Anyone can contribute to this Guide collection!\nHave you written a guide and would like to integrate it into this project, but don\u0026rsquo;t know what Markdown and Hugo are or how to use them? Then just head over to our GitHub repository, create an issue and put your content into the issue description or attach it as a file. We\u0026rsquo;ll handle the conversion for you.\nIf you know your ways around with markdown, then either edit an existing file or create a new one in the content subdirectory. You can do this via the GitHub user interface, GitPod, VSCode.dev or your favorite text editor on your machine.\n","description":"Welcome to the Awesome Open Source Guides, a collection of Guides, Tutorials and Links about using and running Open Source.\nScope This project is focused on the usage of open source and less on running open source projects or maintaining a community. There are other great collections, guides or books about those topics, including but not limited to Cornelius Schumacher\u0026rsquo;s awesome-open-source or Daniel Stenberg\u0026rsquo;s Uncurled.\nContributing Anyone can contribute to this Guide collection!"}]
[{"id":0,"href":"/awesome-open-source-guides/categories/","title":"Categories","parent":"The Awesome Open Source Guides","content":""},{"id":1,"href":"/awesome-open-source-guides/guides/home-assistant/configure-wireguard/","title":"Configure Wireguard VPN for Remote Access","parent":"Guides","content":"Wireguard is a simple, yet powerful VPN solution that is both fast and very easy to setup in contrast to e.g. openVPN. It can be utilized to access your Home Assistant instance securely from anywhere in the world.\nPrerequisites Home Assistant running on a Linux machine a machine with a static hostname/IP, e.g. a VPS in a public cloud Configuring the Server Your server needs to run at least Kernel 5.6 to support Wireguard and you have to install the wireguard userspace tools in addition to that. Find the installation instructions for your operating system on the Wireguard home page.\nWireguard can be installed and configured on the system directly as follows.\nCreate the wireguard keys: ❯ cd /etc/wireguard ❯ umask 077 ❯ wg genkey | tee privatekey | wg pubkey \u0026gt; publickey The public key can then be found in the file /etc/wireguard/publickey while the private key has been written to /etc/wireguard/privatekey.\nKeep the private key secure! Anyone with access to it can impersonate your machine and gain access to your network. Create the configuration file /etc/wireguard/wg0.conf: [Interface] Address = 10.200.200.1/24 ListenPort = 51820 PrivateKey = # insert /etc/wireguard/privatekey here # optional PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE Start the wireguard tunnel via systemctl enable --now wg-quick@wg0 and allow wireguard to be accessed through the firewall. For firewalld execute: firewall-cmd --add-service=wireguard --permanent. Configuring your Home Assistant Machine We have to repeat the first step of the server setup of Wireguard on the machine which is running Home Assistant as well, however our configuration file /etc/wireguard/wg0.conf will be different:\n[Interface] PrivateKey = # insert /etc/wireguard/privatekey here Address = 10.200.200.2/24 PostUp = iptables -A FORWARD -i wg0 -j ACCEPT; iptables -t nat -A POSTROUTING -o wlp59s0 -j MASQUERADE PostDown = iptables -D FORWARD -i wg0 -j ACCEPT; iptables -t nat -D POSTROUTING -o wlp59s0 -j MASQUERADE ListenPort = 51820 [Peer] PublicKey = # /etc/wireguard/publibkey from the server Endpoint = # IP of the server AllowedIPs = 10.200.200.0/24 PersistentKeepalive = 25 # optional, but recommended for reliable reconnects You now have to register this peer on the server as well. Append the following entry to /etc/wireguard/wg0.conf on the server:\n[Peer] PublicKey = # insert /etc/wireguard/publickey of Home Assistant AllowedIPs = 10.200.200.2/32 PersistentKeepalive = 25 # optional, but recommended for reliable reconnects After restarting wireguard on the server via systemctl restart wg-quick@wg0, you can enable wireguard on this machine as well: systemctl enable --now wg-quick@wg0.\nYour Home Assistant machine and the server should now be able to reach each other. You can verify this by e.g. pinging the server from Home Assistant via: ping 10.200.200.1 or by executing wg show wg0 on either of the machines which look roughly like the following:\n# wg show wg0 interface: wg0 public key: VM9jO8G6pH43KIobViKFB9gk3Z9WK65oONLIAa8lEC8= private key: (hidden) listening port: 51820 peer: sA1VKDhTDYDsaEvDHGXhHJMd/nT9NTgD5ICO/DT6V2w= endpoint: # ENDPOINT IP will appear here allowed ips: 10.200.201.0/24 latest handshake: 51 seconds ago transfer: 23.26 MiB received, 15.24 MiB sent persistent keepalive: every 25 seconds Adding peers to your Wireguard VPN Adding a new peer to your VPN is the same process on the server irrespective of the client OS. You have to append a new [Peer] entry to /etc/wireguard/wg0.conf on the server:\n[Peer] PublicKey = # insert /etc/wireguard/publickey or the public key from the new peer AllowedIPs = 10.200.200.N/32 # increment N from your last peer PersistentKeepalive = 25 # optional, but recommended for roaming peers and restart wireguard on the server.\nLinux Adding Linux hosts is completely analogous to configuring the Home Assistant machine. Follow the above guide, but change the Address value in /etc/wireguard/wg0.conf to the same address that you added to the server\u0026rsquo;s /etc/wireguard/wg0.conf.\nWindows Android Connecting your Android phone to the Wireguard network is very simple, especially if you have access to a Linux machine. Then you can generate the configuration for wireguard on the Linux machine and transfer it as a QR code to your phone.\nInstall the Wireguard App from either the Google Play Store or FDroid.\nGenerate a new configuration file as you would for a Linux host and save it somewhere on your file system, e.g. /tmp/wg0.conf.\nConvert the configuration file into a qrcode using qrencode:\nqrencode -t ansiutf8 \u0026lt; \u0026#34;/tmp/wg0.conf\u0026#34; Open the Wireguard App on your phone, click the plus sign in the bottom right corner, select \u0026ldquo;scan from QR code\u0026rdquo; and scan the QR code that appeared in your terminal.\nActivate the connection in the Wireguard App using the toggle next to the tunnel name.\nAlternatives If you do not own a VPS and do not want to run one as your wireguard server, you can use tailscale to setup a wireguard network without a central instance.\nYou can also run wireguard itself from within a container, if you do not want to run it on your host system. This allows you to only allow certain containers to have access to the wireguard network and can be used for a more declarative system configuration. A good wireguard container is Thorsten Kukuk\u0026rsquo;s Wireguard container based on openSUSE or the linuxserver/wireguard image (this one does not function on non-Ubuntu/Debian systems!).\n"},{"id":2,"href":"/awesome-open-source-guides/guides/","title":"Guides","parent":"The Awesome Open Source Guides","content":""},{"id":3,"href":"/awesome-open-source-guides/guides/home-assistant/home-assistant-microos-rpi/","title":"Setting up Home Assistant with openSUSE MicroOS on a Raspberry Pi","parent":"Guides","content":"openSUSE MicroOS is a small operating system designed to run container workloads. It features a read only root partition, transactional updates which allow for easy rollbacks thereby making it highly resilient and perfect for running small IoT devices.\nHome Assistant can be run very easily from within a container preferably on a system requiring as little maintenance as possible. This makes MicroOS the perfect operating system for deploying Home Assistant.\nIn this guide, we will show how to install MicroOS on your Raspberry Pi, configure it with ignition and deploy Home Assistant using podman and systemd.\nPrerequisites You will need the following hardware:\nRaspberry Pi 4 + Power Supply Micro SD-Card USB drive PC with a SD-Card reader and a Micro SD Adapter Ethernet cable This guide will assume that your PC is running Linux. You can perform most of these steps on Windows or MacOS, but some of the commands will require adjustment.\nInstall MicroOS Download the latest MicroOS image (aarch64 variant, Base System + Container Runtime Environment) from download.opensuse.org\nInsert the SD Card into your PC and find out which device name corresponds to it, e.g. via udiskctl status or lsblk:\n❯ udisksctl status MODEL REVISION SERIAL DEVICE -------------------------------------------------------------------------- ADATA SX8200PNP 42G1TBKA 2L08294NSJU9 nvme0n1 ST2000LM007-1R8174 SDM2 WDZG289H sda SE32G 0x0f6986e5 mmcblk0 ❯ # The micro SD Card would be mmcblk0 Flash the downloaded image to the correct device. Double check the correct path or you might accidentally overwrite important data! ❯ xzcat /path/to/download/folder/openSUSE-MicroOS.aarch64-ContainerHost-RaspberryPi.raw.xz | \\ dd bs=4M of=/dev/mmcblk0 iflag=fullblock oflag=direct status=progress # wait a bit ❯ sync Grab the spare USB drive and either create a new partition on it with the label ignition or relabel the existing partition as ignition (e.g. via gparted). Create a directory called ignition in the root directory of the USB drive and put the file config.ign with the following contents into it: { \u0026#34;ignition\u0026#34;: { \u0026#34;version\u0026#34;: \u0026#34;3.0.0\u0026#34; }, \u0026#34;passwd\u0026#34;: { \u0026#34;users\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;root\u0026#34;, \u0026#34;sshAuthorizedKeys\u0026#34;: [ \u0026#34;ssh-rsa insertYourPublicKeyHere\u0026#34; ] } ] } } Replace the line ssh-rsa insertYourPublicKeyHere with your preferred ssh public key that you can find in ~/.ssh/id_*.pub.\nUnmount the SD-Card and the USB drive, insert both into your Raspberry Pi, connect it to your local network using an Ethernet cable and power it on.\nGet the IP address of your Raspberry Pi. You can use your router\u0026rsquo;s web interface for this (if you have access to it). Alternatively, you can scan all PCs in your local network using nmap:\n❯ nmap -p22 -v 192.168.1.* # adjust to your IP range # lots of output... Nmap scan report for 192.168.1.107 Host is up (0.00018s latency). PORT STATE SERVICE 22/tcp open ssh MAC Address: B8:27:EB:64:2C:20 (Raspberry Pi Trading) Or use any other port scanner, e.g. PortAuthority for Android:\nPort authority scan revealing the Raspberry Pi Log in to your Pi and update all packages: ❯ ssh root@$RPI_IP_HERE localhost:~ # transactional-update Checking for newer version. transactional-update 4.0.0~rc4 started Options: Separate /var detected. 2022-08-18 13:35:48 tukit 4.0.0~rc4 started 2022-08-18 13:35:48 Options: -c1 open 2022-08-18 13:35:48 Using snapshot 1 as base for new snapshot 2. 2022-08-18 13:35:48 No previous snapshot to sync with - skipping ID: 2 2022-08-18 13:35:49 Transaction completed. Calling zypper up zypper: nothing to update Removing snapshot #2... 2022-08-18 13:35:52 tukit 4.0.0~rc4 started 2022-08-18 13:35:52 Options: abort 2 2022-08-18 13:35:52 Discarding snapshot 2. 2022-08-18 13:35:52 Transaction completed. transactional-update finished localhost:~ # reboot # only if packages were actually updated Setup Home Assistant We will now setup Home Assistant to be run via podman in a systemd unit and optionally enable automatic updates of the container image.\nLog in to the Raspberry Pi and proceed as follows:\nCreate a directory for Home Assistant\u0026rsquo;s configuration files and database and switch to it: ❯ ssh root@$RPI_IP_HERE localhost:~ # mkdir -p /path/to/conf/dir localhost:~ # podman run -d -v /path/to/conf/dir:/config:Z \\ -v /etc/localtime:/etc/localtime:ro \\ --privileged --network=host \\ --name=homeassistant \\ --label \u0026#34;io.containers.autoupdate=registry\u0026#34; \\ ghcr.io/home-assistant/home-assistant:stable Create a systemd unit using podman and enable it at startup. Now Home Assistant will be automatically started whenever the Raspberry Pi is rebooted. localhost:~ # podman generate systemd --new homeassistant \u0026gt; \\ /etc/systemd/system/homeassistant.service localhost:~ # podman stop homeassistant homeassistant localhost:~ # systemctl daemon-reload localhost:~ # systemctl enable --now homeassistant Created symlink /etc/systemd/system/default.target.wants/homeassistant.service → /etc/systemd/system/homeassistant.service. Depending on your preferences, you can enable automatic updates of the Home Assistant container image using podman\u0026rsquo;s auto-update command. podman will pull a new version of all images with the label io.containers.autoupdate set to registry every time podman auto-update is run. You can either run podman auto-update yourself whenever you consider safe to do or let systemd perform the update periodically by enabling the podman-auto-update.timer: localhost:~ # systemctl enable --now podman-auto-update.timer Created symlink /etc/systemd/system/timers.target.wants/podman-auto-update.timer → /usr/lib/systemd/system/podman-auto-update.timer. Home Assistant is now running on your Raspberry Pi and you can go through the onboarding process.\nGoing forward We have only scratched the surface of what can be achieved with MicroOS as a host operating system. There are multiple areas where this setup can be improved further:\nLeverage (health-checker)[https://github.com/openSUSE/health-checker] to verify whether Home Assistant is able to launch with a new snapshot. Use ignition to its full potential and setup Home Assistant completely automated via ignition. Setup proper monitoring There is a lot to tinker with, so go and check out the MicroOS Portal in the openSUSE Wiki to find out more.\n"},{"id":4,"href":"/awesome-open-source-guides/tags/","title":"Tags","parent":"The Awesome Open Source Guides","content":""},{"id":5,"href":"/awesome-open-source-guides/","title":"The Awesome Open Source Guides","parent":"","content":"Welcome to the Awesome Open Source Guides, a collection of Guides, Tutorials and Links about using and running Open Source.\nScope This project is focused on the usage of open source and less on running open source projects or maintaining a community. There are other great collections, guides or books about those topics, including but not limited to Cornelius Schumacher\u0026rsquo;s awesome-open-source or Daniel Stenberg\u0026rsquo;s Uncurled.\nContributing Anyone can contribute to this Guide collection!\nHave you written a guide and would like to integrate it into this project, but don\u0026rsquo;t know what Markdown and Hugo are or how to use them? Then just head over to our GitHub repository, create an issue and put your content into the issue description or attach it as a file. We\u0026rsquo;ll handle the conversion for you.\nIf you know your ways around with markdown, then either edit an existing file or create a new one in the content subdirectory. You can do this via the GitHub user interface, GitPod, VSCode.dev or your favorite text editor on your machine.\n"}]